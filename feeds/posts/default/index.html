<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Cole Robinson</title><link href="https://blog.wikichoon.com/" rel="alternate"></link><link href="https://blog.wikichoon.com/feeds/all.atom.xml" rel="self"></link><id>https://blog.wikichoon.com/</id><updated>2020-10-03T00:00:00-04:00</updated><subtitle>Cole's dev log</subtitle><entry><title>Better output with /usr/bin/bugzilla --json</title><link href="https://blog.wikichoon.com/2020/10/bugzilla-json-output.html" rel="alternate"></link><published>2020-10-03T00:00:00-04:00</published><updated>2020-10-03T00:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-10-03:/2020/10/bugzilla-json-output.html</id><summary type="html">&lt;p&gt;In python-bugzilla 2.4.0 I added a &lt;code&gt;--json&lt;/code&gt; output switch to &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;IMO this is the optimal way to process large amounts of bugzilla query output
from the command laine. so if you are already doing just that with the old output
options, consider switching to &lt;code&gt;--json …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;In python-bugzilla 2.4.0 I added a &lt;code&gt;--json&lt;/code&gt; output switch to &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;IMO this is the optimal way to process large amounts of bugzilla query output
from the command laine. so if you are already doing just that with the old output
options, consider switching to &lt;code&gt;--json&lt;/code&gt;. That is, if you aren't ready to make the full
leap to using the library directly ;)&lt;/p&gt;
&lt;h4&gt;Replace usage of &lt;code&gt;--raw&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The older &lt;code&gt;--raw&lt;/code&gt; output mode will print bug contents in a strange custom array-like output
format that is poorly specified and impossible to parse reliably. Please use &lt;code&gt;--json&lt;/code&gt; instead.
&lt;code&gt;--raw&lt;/code&gt; may be removed in the future.&lt;/p&gt;
&lt;h4&gt;Replace usage of &lt;code&gt;--outputformat&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The older &lt;code&gt;--outputformat&lt;/code&gt; option processes bug contents and prints them out in the
specified string format. Variables are referenced with something akin to RPM macro
format. Example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ bugzilla query --outputformat &lt;span class="s1"&gt;&amp;#39;%{id}::%{summary}&amp;#39;&lt;/span&gt; --id &lt;span class="m"&gt;1234567&lt;/span&gt;
&lt;span class="m"&gt;1234567&lt;/span&gt;::Package should not ship a separate emacs sub-package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This has served us pretty well, but besides being a custom and poorly specified
format, it has limitations with formatting subvalues of non-string bugzilla fields.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;--json&lt;/code&gt; you can make use of the powerful &lt;code&gt;jq&lt;/code&gt; tool which
gives you the ability to do all manner of querying and processing of
the output.&lt;/p&gt;
&lt;p&gt;This example duplicates the &lt;code&gt;--outputformat&lt;/code&gt; example above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;bugzilla query --json --id &lt;span class="m"&gt;1234567&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq -r &lt;span class="s1"&gt;&amp;#39;.bugs[0] | &amp;quot;\(.id)::\(.summary)&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;1234567::Package should not ship a separate emacs sub-package&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This example demonstrates accessing a structured subfield like &lt;code&gt;comments&lt;/code&gt;. We print the first comment's creation time for a list of bugs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;bugzilla query --json &lt;span class="se"&gt;\&lt;/span&gt;
    --product Fedora --component virt-manager --status OPEN &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    jq -r &lt;span class="s2"&gt;&amp;quot;.bugs[].comments[0].creation_time&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;2020-07-08T16:35:14Z&lt;/span&gt;
&lt;span class="go"&gt;2020-08-30T14:22:42Z&lt;/span&gt;
&lt;span class="go"&gt;2020-04-12T20:28:24Z&lt;/span&gt;
&lt;span class="go"&gt;2020-02-05T09:57:48Z&lt;/span&gt;
&lt;span class="go"&gt;2020-09-09T15:17:32Z&lt;/span&gt;
&lt;span class="go"&gt;2019-12-28T22:29:05Z&lt;/span&gt;
&lt;span class="go"&gt;2020-08-15T21:20:02Z&lt;/span&gt;
&lt;span class="go"&gt;2020-09-21T13:59:37Z&lt;/span&gt;
&lt;span class="go"&gt;2020-09-18T08:50:28Z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Optimizing &lt;code&gt;--json&lt;/code&gt; queried data&lt;/h4&gt;
&lt;p&gt;One downside of &lt;code&gt;--json&lt;/code&gt; compared to &lt;code&gt;--outputformat&lt;/code&gt; is that it will return
all bug data even if you only plan to parse a subset of it. For big queries,
or ones performed repeatedly, this can cause unnecessary load on the bugzilla
instance.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--outputformat&lt;/code&gt; knows what fields you need, so will only fetch those from
the bugzilla instance, transferring the minimally required amount of data.
You can achieve the same thing manually with &lt;code&gt;--json&lt;/code&gt; by also specifying
the option &lt;code&gt;--includefield field1 --includefield field2 ..&lt;/code&gt; for every
field you need to process. Example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;bugzilla query --json --includefield summary --id &lt;span class="m"&gt;1234567&lt;/span&gt;
&lt;span class="go"&gt;{&lt;/span&gt;
&lt;span class="go"&gt;  &amp;quot;bugs&amp;quot;: [&lt;/span&gt;
&lt;span class="go"&gt;    {&lt;/span&gt;
&lt;span class="go"&gt;      &amp;quot;id&amp;quot;: 1234567,&lt;/span&gt;
&lt;span class="go"&gt;      &amp;quot;summary&amp;quot;: &amp;quot;Package should not ship a separate emacs sub-package&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;
&lt;span class="go"&gt;  ]&lt;/span&gt;
&lt;span class="go"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As a more general tip, use the bugzilla web UI to generate a query that
only checks for changes after a certain timestamp that is relevant to
you, and pass that to
&lt;a href="https://blog.wikichoon.com/2014/05/invoking-bugzilla-query-url-from.html"&gt;&lt;code&gt;query --from-url $URL&lt;/code&gt;&lt;/a&gt;,
so you can limit the time window for the data you are fetching.&lt;/p&gt;
&lt;h4&gt;Using &lt;code&gt;--json&lt;/code&gt; to find bugzilla API field names&lt;/h4&gt;
&lt;p&gt;This applies to &lt;code&gt;--raw&lt;/code&gt; as well, but you can use &lt;code&gt;--json&lt;/code&gt; to find out the
API name of custom fields in the bugzilla instance. Many times I've been asked
questions like: 'How do I access bugzilla.redhat.com field FOOBAR from python-bugzilla?'.
The simplest way to figure it out is to find a bug that you know has data filled in for
that field, pass that bug ID to &lt;code&gt;bugzilla query --json --id XXX&lt;/code&gt; and examine the output
to find the field name. If they are custom fields they usually have a prefix like &lt;code&gt;cf_&lt;/code&gt;,
at least for bugzilla.redhat.com.&lt;/p&gt;</content><category term="fedora"></category></entry><entry><title>virt-install --cloud-init support</title><link href="https://blog.wikichoon.com/2020/09/virt-install-cloud-init.html" rel="alternate"></link><published>2020-09-26T00:00:00-04:00</published><updated>2020-09-26T00:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-09-26:/2020/09/virt-install-cloud-init.html</id><summary type="html">&lt;p&gt;As part of GSOC 2019, &lt;a href="https://athinapl.home.blog/2019/08/25/gsoc-2019-cloud-init-configuration-for-virt-manager-virt-install/"&gt;Athina Plaskasoviti implemented &lt;code&gt;--cloud-init&lt;/code&gt; support for virt-install&lt;/a&gt;. This post provides a bit more info about the feature.&lt;/p&gt;
&lt;h4&gt;Why cloud-init&lt;/h4&gt;
&lt;p&gt;For a long while, most mainstream Linux distros have shipped 'cloud images': &lt;code&gt;raw&lt;/code&gt; or &lt;code&gt;qcow2&lt;/code&gt; formatted disk images with the distro minimally pre-installed on it. These …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As part of GSOC 2019, &lt;a href="https://athinapl.home.blog/2019/08/25/gsoc-2019-cloud-init-configuration-for-virt-manager-virt-install/"&gt;Athina Plaskasoviti implemented &lt;code&gt;--cloud-init&lt;/code&gt; support for virt-install&lt;/a&gt;. This post provides a bit more info about the feature.&lt;/p&gt;
&lt;h4&gt;Why cloud-init&lt;/h4&gt;
&lt;p&gt;For a long while, most mainstream Linux distros have shipped 'cloud images': &lt;code&gt;raw&lt;/code&gt; or &lt;code&gt;qcow2&lt;/code&gt; formatted disk images with the distro minimally pre-installed on it. These images typically have &lt;a href="https://cloud-init.io/"&gt;cloud-init&lt;/a&gt; set to run on VM bootup. cloud-init can do a variety of things, like add users, change passwords, register ssh keys, and generally perform any desired action on the VM OS. This only works when cloud-init is passed the right configuration by whatever platform is starting the VM, like OpenStack or virt-install. cloud-init supports many different &lt;a href="https://cloudinit.readthedocs.io/en/latest/topics/datasources.html"&gt;datasources&lt;/a&gt; for getting configuration outside the VM.&lt;/p&gt;
&lt;p&gt;Historically though the problem is that slapping these images into virt-install or virt-manager gives crappy results, because these tools were not providing any datasource. In this case, cloud-init reverts to its distro default configured behavior, which in most cases is unusable. For example on Fedora, the result was: hang waiting for cloud-init data, time out, drop to login prompt with all accounts locked.&lt;/p&gt;
&lt;p&gt;Prior to virt-install &lt;code&gt;--cloud-init&lt;/code&gt; support, the simplest workaround was to use libguestfs, specifically &lt;code&gt;virt-customize&lt;/code&gt;, to set a root password and disable cloud-init:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;virt-customize -a MY-CLOUD-IMAGE.qcow2 &lt;span class="se"&gt;\&lt;/span&gt;
    --root-password password:SUPER-SECRET-PASSWORD &lt;span class="se"&gt;\&lt;/span&gt;
    --uninstall cloud-init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;--cloud-init option&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;--cloud-init&lt;/code&gt; option will tell virt-install to set up a &lt;a href="https://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html"&gt;nocloud&lt;/a&gt; datasource via a specially formatted &lt;code&gt;.iso&lt;/code&gt; file that is generated on the fly, and only used for the first VM bootup.&lt;/p&gt;
&lt;p&gt;The default behavior when &lt;code&gt;--cloud-init&lt;/code&gt; is specified with no suboptions will do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generate a random root password and print it to the terminal.&lt;/li&gt;
&lt;li&gt;Default to VM serial console access rather than graphical console access. Makes it easier to paste the password and gives more ssh-like behavior.&lt;/li&gt;
&lt;li&gt;Sets the root password to expire on first login. So the temporary password is only used once.&lt;/li&gt;
&lt;li&gt;Disables cloud-init for subsequent VM startups. Otherwise on the next VM boot you'd face locked accounts again.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;--cloud-init&lt;/code&gt; also has suboptions to specify your own behavior, like transfer in a host ssh public key, pass in raw cloud-init &lt;code&gt;user-data&lt;/code&gt;/&lt;code&gt;meta-data&lt;/code&gt;, etc. See the &lt;a href="https://github.com/virt-manager/virt-manager/blob/master/man/virt-install.rst#--cloud-init"&gt;virt-install --cloud-init man page section&lt;/a&gt; for the specifics.&lt;/p&gt;
&lt;h4&gt;Room for improvement&lt;/h4&gt;
&lt;p&gt;This is all a step in the right direction but there's lots more we can do here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extend virt-install's &lt;code&gt;--install&lt;/code&gt; option to learn how to fetch cloud images for the specified distro. &lt;a href="https://libosinfo.org/"&gt;libosinfo&lt;/a&gt; and &lt;a href="https://gitlab.com/libosinfo/osinfo-db"&gt;osinfo-db&lt;/a&gt; already track cloud image download links for many distros so the info we need is already in place. We could make &lt;code&gt;virt-install --install fedora32,cloud=yes&lt;/code&gt; a single way to pull down a cloud image, generate a cloud-init datasource, and create the VM in one shot.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;--cloud-init&lt;/code&gt; by default when the user passes us a cloud-init enabled disk image. &lt;code&gt;virt-customize&lt;/code&gt; has a lot of disk image detection smarts already, but we aren't using that in virt-install yet.&lt;/li&gt;
&lt;li&gt;virt-manager UI support. There's an &lt;a href="https://github.com/virt-manager/virt-manager/issues/143"&gt;issue tracking this&lt;/a&gt; with some more thoughts in it.&lt;/li&gt;
&lt;li&gt;Similar support for &lt;a href="https://coreos.com/ignition/"&gt;CoreOS Ignition&lt;/a&gt; which fulfills a similar purpose as cloud-init for distros like &lt;a href="https://getfedora.org/en/coreos/"&gt;Fedora CoreOS&lt;/a&gt;. There's an &lt;a href="https://github.com/virt-manager/virt-manager/issues/152"&gt;issue tracking this too&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I personally don't have plans to work on these any time soon, but I'm happy to provide guidance if anyone is interested in helping out!&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>virt-manager 3.0.0 released!</title><link href="https://blog.wikichoon.com/2020/09/virt-manager-300-released.html" rel="alternate"></link><published>2020-09-16T00:00:00-04:00</published><updated>2020-09-16T00:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-09-16:/2020/09/virt-manager-300-released.html</id><summary type="html">&lt;p&gt;Yesterday I released &lt;a href="https://www.redhat.com/archives/virt-tools-list/2020-September/msg00003.html"&gt;virt-manager 3.0.0&lt;/a&gt;. Despite the major version number bump, things shouldn't look too different from the previous release. For me the major version number bump reflects certain feature removals (like dropping virt-convert), and the large amount of internal code changes that were done, though there's a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Yesterday I released &lt;a href="https://www.redhat.com/archives/virt-tools-list/2020-September/msg00003.html"&gt;virt-manager 3.0.0&lt;/a&gt;. Despite the major version number bump, things shouldn't look too different from the previous release. For me the major version number bump reflects certain feature removals (like dropping virt-convert), and the large amount of internal code changes that were done, though there's a few long awaited features sprinkled in like virt-install &lt;code&gt;--cloud-init&lt;/code&gt; support which I plan to write more about later.&lt;/p&gt;
&lt;p&gt;This release includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virt-install --cloud-init support (&lt;a href="https://athinapl.home.blog/2019/08/25/gsoc-2019-cloud-init-configuration-for-virt-manager-virt-install/"&gt;Athina Plaskasoviti&lt;/a&gt;, Cole Robinson)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.wikichoon.com/2020/07/virt-convert-removed.html"&gt;The virt-convert tool has been removed&lt;/a&gt;. Please use virt-v2v instead&lt;/li&gt;
&lt;li&gt;A handful of UI XML configuration options have been removed, in an effort to reduce maintenance ongoing maintenance burden, and to be more consistent with what types of UI knobs we expose. The &lt;a href="https://blog.wikichoon.com/2020/07/virt-manager-xml-editor.html"&gt;XML editor&lt;/a&gt; is an alternative in most cases. For a larger discussion see &lt;a href="https://www.redhat.com/archives/virt-tools-list/2019-June/msg00117.html"&gt;this thread&lt;/a&gt; and virt-manager's &lt;a href="https://github.com/virt-manager/virt-manager/blob/master/DESIGN.md"&gt;DESIGN.md&lt;/a&gt; file.&lt;/li&gt;
&lt;li&gt;The 'New VM' UI now has a 'Manual Install' option which creates a VM without any required install media&lt;/li&gt;
&lt;li&gt;In the 'New VM' UI, the network/pxe install option has been removed. If you need network boot, choose 'Manual Install' and set the boot device after initial VM creation&lt;/li&gt;
&lt;li&gt;'Clone VM' UI has been reworked and simplified&lt;/li&gt;
&lt;li&gt;'Migrate VM' UI now has an XML editor for the destination VM&lt;/li&gt;
&lt;li&gt;Global and per-vm option to disable graphical console autoconnect. This makes it easier to use virt-manager alongside another client like virt-viewer&lt;/li&gt;
&lt;li&gt;virt-manager: set guest time after VM restore (Michael Weiser)&lt;/li&gt;
&lt;li&gt;virt-manager: option to delete storage when removing disk device (Lily Nie)&lt;/li&gt;
&lt;li&gt;virt-manager: show warnings if snapshot operation is unsafe (Michael Weiser)&lt;/li&gt;
&lt;li&gt;Unattended install improvements (Fabiano Fidêncio)&lt;/li&gt;
&lt;li&gt;cli: new --xml XPATH=VAL option for making direct XML changes&lt;/li&gt;
&lt;li&gt;virt-install: new --reinstall=DOMAIN option&lt;/li&gt;
&lt;li&gt;virt-install: new --autoconsole text|graphical|none option&lt;/li&gt;
&lt;li&gt;virt-install: new --os-variant detect=on,require=on suboptions&lt;/li&gt;
&lt;li&gt;cli: --clock, --keywrap, --blkiotune, --cputune additions (Athina Plaskasoviti)&lt;/li&gt;
&lt;li&gt;cli: add --features kvm.hint-dedicated.state= (Menno Lageman)&lt;/li&gt;
&lt;li&gt;cli: add --iommu option (Menno Lageman)&lt;/li&gt;
&lt;li&gt;cli: Add --graphics websocket= support (Petr Benes)&lt;/li&gt;
&lt;li&gt;cli: Add --disk type=nvme source.* suboptions&lt;/li&gt;
&lt;li&gt;cli: Fill in all --filesystem suboptions&lt;/li&gt;
&lt;li&gt;Translation string improvements (Pino Toscano)&lt;/li&gt;
&lt;li&gt;Convert from .pod to .rst for man pages&lt;/li&gt;
&lt;li&gt;Switch to pytest as our test runner&lt;/li&gt;
&lt;li&gt;Massively improved unittest and uitest code coverage&lt;/li&gt;
&lt;li&gt;Now using github issues as our bug tracker&lt;/li&gt;
&lt;/ul&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>virt-manager libvirt XML editor UI</title><link href="https://blog.wikichoon.com/2020/07/virt-manager-xml-editor.html" rel="alternate"></link><published>2020-07-12T00:00:00-04:00</published><updated>2020-07-12T00:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-07-12:/2020/07/virt-manager-xml-editor.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.redhat.com/archives/virt-tools-list/2019-June/msg00099.html"&gt;virt-manager 2.2.0&lt;/a&gt; was released in June of last year. It shipped with a major new feature: libvirt XML viewing and editing UI for new and existing domain, pools, volumes, networks.&lt;/p&gt;
&lt;p&gt;Every VM, network, and storage object page has a &lt;strong&gt;XML&lt;/strong&gt; tab at the top. Here's an example with …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.redhat.com/archives/virt-tools-list/2019-June/msg00099.html"&gt;virt-manager 2.2.0&lt;/a&gt; was released in June of last year. It shipped with a major new feature: libvirt XML viewing and editing UI for new and existing domain, pools, volumes, networks.&lt;/p&gt;
&lt;p&gt;Every VM, network, and storage object page has a &lt;strong&gt;XML&lt;/strong&gt; tab at the top. Here's an example with that tab selected from the VM &lt;strong&gt;Overview&lt;/strong&gt; section:&lt;/p&gt;
&lt;p&gt;&lt;img alt="VM XML editor" src="https://blog.wikichoon.com/images/079-xml1.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;Here's an example of the XML view when just a disk is selected. Note it only shows that single device's libvirt XML:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Disk XML editor" src="https://blog.wikichoon.com/images/079-xml2.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;By default the XML is not editable; notice the warning at the top of the first image. After editing is enabled, the warning is gone, like in the second image. You can enable editing via Edit-&amp;gt;Preferences from the main &lt;strong&gt;Manager&lt;/strong&gt; window. Here's what the option looks like:&lt;/p&gt;
&lt;p&gt;&lt;img alt="XML edit preference" src="https://blog.wikichoon.com/images/079-xml-prefs.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;A bit of background: We are constantly receiving requests to expose libvirt XML config options in virt-manager's UI. Some of these knobs are necessary for &amp;lt;1% but uninteresting to the rest. Some options are difficult to set from the command line because they must be set at VM install time, which means switch from virt-manager to virt-install which is not trivial. And so on. When these options aren't added to the UI, it makes life difficult for those affected users. It's also difficult and draining to have these types of justification conversations on the regular.&lt;/p&gt;
&lt;p&gt;The XML editing UI was added to relieve some of the pressure on virt-manager developers fielding these requests, and to give more power to advanced virt users. The users that know they need an advanced option are usually comfortable editing the libvirt XML directly. The XML editor doesn't detract from the existing UI much IMO, and it is uneditable by default to prevent less knowledgeable users from getting into trouble. It ain't gonna win any awards for great UI, but the feedback has been largely positive so far.&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>virt-convert tool removed in virt-manager.git</title><link href="https://blog.wikichoon.com/2020/07/virt-convert-removed.html" rel="alternate"></link><published>2020-07-11T00:00:00-04:00</published><updated>2020-07-11T00:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-07-11:/2020/07/virt-convert-removed.html</id><summary type="html">&lt;p&gt;The next release of virt-manager will not ship the &lt;code&gt;virt-convert&lt;/code&gt; tool, I removed it upstream with &lt;a href="https://github.com/virt-manager/virt-manager/commit/ee9f93074bf74bd2e4c5177d750e7c438c7790cf"&gt;this commit&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's the slightly edited quote from my original proposal to remove it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;virt-convert takes an ovf/ova or vmx file and spits out libvirt XML.
It started as a code drop a …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;The next release of virt-manager will not ship the &lt;code&gt;virt-convert&lt;/code&gt; tool, I removed it upstream with &lt;a href="https://github.com/virt-manager/virt-manager/commit/ee9f93074bf74bd2e4c5177d750e7c438c7790cf"&gt;this commit&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here's the slightly edited quote from my original proposal to remove it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;virt-convert takes an ovf/ova or vmx file and spits out libvirt XML.
It started as a code drop a long time ago that could translate back and
forth between vmx, ovf, and virt-image, a &lt;a href="https://blog.wikichoon.com/2014/04/deprecating-little-used-tool-virt-image1.html"&gt;long dead appliance format&lt;/a&gt;.
In 2014 I &lt;a href="https://blog.wikichoon.com/2014/04/virt-convert-command-line-has-been.html"&gt;changed virt-convert&lt;/a&gt; to do vmx -&amp;gt; libvirt and ovf -&amp;gt;
libvirt which was a CLI breaking change, but I never heard a peep of a
complaint. It doesn't do a particularly thorough job at its
intended goal, I've seen 2-3 bug reports in the past 5 years and
generally it doesn't seem to have any users. Let's kill it. If anyone
has the desire to keep it alive it could live as a separate project
that's a wrapper around virt-install but there's no compelling reason to
keep it in virt-manager.git IMO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That mostly sums it up. If there's any users of virt-convert out there, you likely
can get similar results by extracting the relevant disk image from the
&lt;code&gt;.vmx&lt;/code&gt; or &lt;code&gt;.ovf&lt;/code&gt; config, pass it to &lt;code&gt;virt-manager&lt;/code&gt; or &lt;code&gt;virt-install&lt;/code&gt;, and let
those tools fill in the defaults. In truth that's about all &lt;code&gt;virt-convert&lt;/code&gt; did in
to begin with.&lt;/p&gt;
&lt;p&gt;Please see &lt;a href="https://libguestfs.org/virt-v2v.1.html"&gt;&lt;code&gt;virt-v2v&lt;/code&gt;&lt;/a&gt; for an actively maintained tool that can covert OVA/OVF appliances to libvirt + KVM. &lt;a href="https://www.redhat.com/en/blog/importing-vms-kvm-virt-v2v"&gt;This redhat.com article&lt;/a&gt; describes an example conversion.&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>python-bugzilla REST API support</title><link href="https://blog.wikichoon.com/2020/06/python-bugzilla-rest-api.html" rel="alternate"></link><published>2020-06-29T13:00:00-04:00</published><updated>2020-06-29T13:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-06-29:/2020/06/python-bugzilla-rest-api.html</id><summary type="html">&lt;p&gt;I just released &lt;strong&gt;&lt;a href="https://github.com/python-bugzilla/python-bugzilla"&gt;python-bugzilla&lt;/a&gt; 2.4.0&lt;/strong&gt;. The main interesting bit it adds is support for &lt;a href="https://wiki.mozilla.org/Bugzilla:REST_API"&gt;Bugzilla's REST API&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All previous versions of python-bugzilla and &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; only used the XMLRPC API, but that is deprecated in Bugzilla 5.0+ and all new API development is taking place on …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I just released &lt;strong&gt;&lt;a href="https://github.com/python-bugzilla/python-bugzilla"&gt;python-bugzilla&lt;/a&gt; 2.4.0&lt;/strong&gt;. The main interesting bit it adds is support for &lt;a href="https://wiki.mozilla.org/Bugzilla:REST_API"&gt;Bugzilla's REST API&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All previous versions of python-bugzilla and &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; only used the XMLRPC API, but that is deprecated in Bugzilla 5.0+ and all new API development is taking place on the REST API.&lt;/p&gt;
&lt;p&gt;In practice there isn't any released bugzilla version that has big differences between the two API versions. On bugzilla.redhat.com specifically the XMLRPC API is still recommended, because some custom features are not available over REST yet. Note though that bugzilla.mozilla.org is looking at &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1599274"&gt;disabling the XMLRPC API entirely&lt;/a&gt;, but they are usually ahead of the Bugzilla curve.&lt;/p&gt;
&lt;p&gt;By default, python-bugzilla will use some URL parsing heuristics to try to guess if the
passed URL is for XMLRPC or REST.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If URL contains &lt;code&gt;/xmlrpc&lt;/code&gt;, assume XMLRPC&lt;/li&gt;
&lt;li&gt;If URL contains &lt;code&gt;/rest&lt;/code&gt;, assume REST&lt;/li&gt;
&lt;li&gt;If the URL does not contain a path:&lt;ul&gt;
&lt;li&gt;Try appending &lt;code&gt;/xmlrpc.cgi&lt;/code&gt; and if the URL exists, use it&lt;/li&gt;
&lt;li&gt;Try appending &lt;code&gt;/rest&lt;/code&gt; and if the URL exists, use it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Otherwise just attempt to initialize the XMLRPC backend&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In practice this should mean previously used URLs will continue to use XMLRPC.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Bugzilla&lt;/code&gt; API class also &lt;code&gt;force_rest&lt;/code&gt; and &lt;code&gt;force_xmlrpc&lt;/code&gt; init arguments to
force use of a specific API for the passed URL. Whether REST or XMLRPC is used
the existing API should continue to work as expected, it's simply a backend detail.&lt;/p&gt;
&lt;p&gt;From &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; there aren't any explicit command line options to force
use of one API or the other. If you pass a URL with an explicit &lt;code&gt;/rest&lt;/code&gt; or
&lt;code&gt;/xmlrpc.cgi&lt;/code&gt; then the API will pick the correct backend based on the heuristic
above. If your URL has a weirdly named REST API endpoint you can probably trick
the heuristic with a funky URL like &lt;code&gt;https://fakebz.example.com/weird-rest-endpoint?/rest&lt;/code&gt;&lt;/p&gt;</content><category term="fedora"></category></entry><entry><title>virt-manager is deprecated in RHEL (but only RHEL)</title><link href="https://blog.wikichoon.com/2020/06/virt-manager-deprecated-in-rhel.html" rel="alternate"></link><published>2020-06-16T13:00:00-04:00</published><updated>2020-06-16T13:00:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2020-06-16:/2020/06/virt-manager-deprecated-in-rhel.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: I'm the primary author of virt-manager. virt-manager is deprecated in RHEL8 in favor of cockpit, but ONLY in RHEL8 and future RHEL releases. The upstream project virt-manager is still maintained and is still relevant for other distros.&lt;/p&gt;
&lt;p&gt;Google 'virt-manager deprecated' and you'll find some discussions suggesting
virt-manager is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: I'm the primary author of virt-manager. virt-manager is deprecated in RHEL8 in favor of cockpit, but ONLY in RHEL8 and future RHEL releases. The upstream project virt-manager is still maintained and is still relevant for other distros.&lt;/p&gt;
&lt;p&gt;Google 'virt-manager deprecated' and you'll find some discussions suggesting
virt-manager is no longer maintained, &lt;a href="https://cockpit-project.org/"&gt;Cockpit&lt;/a&gt; is replacing virt-manager, virt-manager is going to be removed from every distro, etc. These conclusions are misinformed.&lt;/p&gt;
&lt;p&gt;The primary source for this confusion is the section 'virt-manager has been deprecated' from the &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.2_release_notes/deprecated_functionality#deprecated-functionality_virtualization"&gt;RHEL8 release notes virtualization deprecation section&lt;/a&gt;. Relevant quote from the RHEL8.2 docs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Virtual Machine Manager application, also known as virt-manager, has been deprecated.
The RHEL 8 web console, also known as Cockpit, is intended to become its replacement in a subsequent release.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What that means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virt-manager is in RHEL8 and will be there for the lifetime of RHEL8.&lt;/li&gt;
&lt;li&gt;Red Hat engineering effort assigned to the virt-manager UI has been reduced compared to previous RHEL versions.&lt;/li&gt;
&lt;li&gt;The tentative plan is to not ship the virt-manager UI in RHEL9.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why is this happening? As I understand it, RHEL wants to roughly standardize on Cockpit as their host admin UI tool. It's a great project with great engineers and great UI designers. Red Hat is going all in on it for RHEL and aims to replace the mismash of system-config-X tools and project specific admin frontends (like virt-manager) with a unified project. (Please note: this is my paraphrased understanding, I'm not speaking on behalf of Red Hat here.)&lt;/p&gt;
&lt;p&gt;Notice though, this is all about RHEL. virt-manager is not deprecated upstream, or deprecated in other distros automatically just because RHEL has made this decision. The upstream virt-manager project continues on and Red Hat continues to allocate resources to maintain it.&lt;/p&gt;
&lt;p&gt;Also, I'm distinguishing virt-manager UI from the virt-manager project, which includes tools like &lt;code&gt;virt-install&lt;/code&gt;. I fully expect &lt;code&gt;virt-install&lt;/code&gt; to be shipped in RHEL9 and actively maintained (FWIW Cockpit uses it behind the scenes).&lt;/p&gt;
&lt;p&gt;And even if the virt-manager UI is not in RHEL9 repos, it will likely end up shipped in EPEL, so the UI will still be available for install, just through external repos.&lt;/p&gt;
&lt;p&gt;Overall my personal opinion is that as long as libvirt+KVM is in use on linux desktops and servers, virt-manager will be relevant. I don't expect anything to change in that area any time soon.&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>Blog moved to Pelican and GitHub Pages</title><link href="https://blog.wikichoon.com/2019/07/blog-moved.html" rel="alternate"></link><published>2019-07-30T15:30:00-04:00</published><updated>2019-07-30T15:30:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2019-07-30:/2019/07/blog-moved.html</id><summary type="html">&lt;p&gt;I've moved my blog from blogger.com to a static site generated with
&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt; and hosted on GitHub Pages. This
is a dump of some of the details.&lt;/p&gt;
&lt;p&gt;The content is hosted in three branches across two repos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/crobinso/blog/tree/gh-pages"&gt;blog/gh-pages&lt;/a&gt;&lt;/strong&gt;: &lt;a href="https://blog.wikichoon.com"&gt;https://blog.wikichoon.com&lt;/a&gt; HTML content&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/crobinso/crobinso.github.io/tree/master"&gt;crobinso.github.io/master …&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;I've moved my blog from blogger.com to a static site generated with
&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt; and hosted on GitHub Pages. This
is a dump of some of the details.&lt;/p&gt;
&lt;p&gt;The content is hosted in three branches across two repos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/crobinso/blog/tree/gh-pages"&gt;blog/gh-pages&lt;/a&gt;&lt;/strong&gt;: &lt;a href="https://blog.wikichoon.com"&gt;https://blog.wikichoon.com&lt;/a&gt; HTML content&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/crobinso/crobinso.github.io/tree/master"&gt;crobinso.github.io/master&lt;/a&gt;&lt;/strong&gt;: &lt;a href="https://wikichoon.com"&gt;https://wikichoon.com&lt;/a&gt; front page HTML content&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/crobinso/crobinso.github.io/tree/pelican"&gt;crobinso.github.io/pelican&lt;/a&gt;&lt;/strong&gt;: website source content and theme&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The motivation for the split is that according to this &lt;a href="https://blog.kmonsoor.com/pelican-how-to-make-seo-friendly/"&gt;pelican SEO&lt;/a&gt; article, &lt;strong&gt;master&lt;/strong&gt; branches of GitHub repos are indexed by google, so if you store HTML content in a &lt;strong&gt;master&lt;/strong&gt; branch your canonical blog might be battling your GitHub repo in the search results. And since you can only put content in the &lt;strong&gt;master&lt;/strong&gt; branch of a &lt;code&gt;$username.github.io&lt;/code&gt; repo, I added a separate blog.git repo. Maybe I could shove all the content into the &lt;strong&gt;blog/gh-pages&lt;/strong&gt; branch I think dealing with multiple subdomains prevents it. I've already spent too much timing playing with all this stuff though so that's for another day to figure out. Of course, suggestions welcome, blog comments are enabled with Disqus.&lt;/p&gt;
&lt;p&gt;One issue I hit is that pushing updated content to &lt;strong&gt;blog/gh-pages&lt;/strong&gt; doesn't consistently trigger a new GitHub Pages deployment. There's a bunch of hits about this around the web (this &lt;a href="https://stackoverflow.com/questions/20422279/github-pages-are-not-updating"&gt;stackoverflow post&lt;/a&gt; in particular) but no authoritative explanation about what criteria GitHub Pages uses to determine whether to redeploy. The simplest 'fix' I found is to tweak the &lt;code&gt;index.html&lt;/code&gt; content via the GitHub web UI and commit the change which seems to consistently trigger a refresh as reported by the repo's &lt;a href="https://github.com/crobinso/blog/deployments"&gt;deployments page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You may notice the blog looks a lot like stock &lt;a href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; with its &lt;a href="https://github.com/jekyll/minima"&gt;minima&lt;/a&gt; theme. I didn't find any Pelican theme that I liked as much as minima, so I grabbed the CSS from a minima instance and started adapting the Pelican &lt;a href="https://github.com/getpelican/pelican-themes/tree/master/simple-bootstrap"&gt;simple-bootstrap&lt;/a&gt; theme to use it. The end result is basically a simple reimplementation of minima for Pelican. I learned a lot in the process but it likely would have been much simpler if I just used Jekyll in the first place, but I'm in too deep to switch now!&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>Host 'Network Interfaces' panel removed from virt-manager</title><link href="https://blog.wikichoon.com/2019/04/host-network-interfaces-panel-removed.html" rel="alternate"></link><published>2019-04-09T14:01:00-04:00</published><updated>2019-04-09T14:01:00-04:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2019-04-09:/2019/04/host-network-interfaces-panel-removed.html</id><summary type="html">&lt;p&gt;I released &lt;a href="https://www.redhat.com/archives/virt-tools-list/2018-October/msg00087.html"&gt;virt-manager 2.0.0&lt;/a&gt; in October 2018. Since the release contained the full port to python3, it seemed like a good opportunity to drop some baggage from the app.&lt;/p&gt;
&lt;p&gt;The biggest piece we removed was the UI for managing host network interfaces. This is the &lt;strong&gt;Connection Details-&amp;gt;Network …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;I released &lt;a href="https://www.redhat.com/archives/virt-tools-list/2018-October/msg00087.html"&gt;virt-manager 2.0.0&lt;/a&gt; in October 2018. Since the release contained the full port to python3, it seemed like a good opportunity to drop some baggage from the app.&lt;/p&gt;
&lt;p&gt;The biggest piece we removed was the UI for managing host network interfaces. This is the &lt;strong&gt;Connection Details-&amp;gt;Network Interfaces&lt;/strong&gt; panel, and the &lt;strong&gt;New Interface&lt;/strong&gt; wizard for defining host network definitions for things like bridges, bonds, and vlan devices. The main screen of the old UI looked like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="virt-manager host interfaces panel" height="280" src="https://blog.wikichoon.com/images/074-host-network-interfaces-panel-removed-1.png" width="400"&gt;&lt;/p&gt;
&lt;h4&gt;Some history&lt;/h4&gt;
&lt;p&gt;Behind the scenes, this UI was using libvirt's Interface APIs, which also power the &lt;code&gt;virsh iface-*&lt;/code&gt; commands. These APIs are little more than a wrapper around the &lt;a href="https://pagure.io/netcf"&gt;netcf&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;netcf aimed to be a linux distro independent API for network device configuration. On Red Hat distros this meant turning the API's XML format into an &lt;code&gt;/etc/sysconfig/network&lt;/code&gt; script. There were even pie-in-the-sky ideas about NetworkManager one day using netcf.&lt;/p&gt;
&lt;p&gt;In practice though the library never really took off. It was years before a debian backend showed up, contributed by a Red Hatter in the hope of increasing library uptake, though it didn't seem to help. netcf basically only existed to serve the libvirt Interface APIs, yet those APIs were never really used by any major libvirt consuming app, besides virt-manager. And in virt-manager's case it was largely just slapping some UI over the XML format and lifecycle operations.&lt;/p&gt;
&lt;p&gt;For virt-manager's usecases we hoped that netcf would make it trivial to bridge the host's network interface, which when used with VMs would give them first class IP addresses on the host network setup, not NAT like the 'default' virtual network. Unfortunately though the UI would create the ifcfg files well enough, behind the scenes nothing played well with NetworkManager for years and years. The standard suggestion for was to disable NetworkManager if you wanted to bridge your host NIC. Not very user friendly. Some people did manage to use the UI to that effect but it was never a trivial process.&lt;/p&gt;
&lt;h4&gt;The state today&lt;/h4&gt;
&lt;p&gt;Nowadays NetworkManager can handle bridging natively and is much more powerful than what virt-manager/libvirt/netcf provide. The virt-manager UI was more likely to shoot you in the foot than make things simple. And it had become increasingly clear that virt-manager was not the place to maintain host network config UI.&lt;/p&gt;
&lt;p&gt;So we made the decision to drop all this from virt-manager in 2.0.0. netcf and the libvirt interface APIs still exist. If you're interested in some more history on the interface API/netcf difficulties, check out &lt;a href="https://www.redhat.com/archives/virt-tools-list/2018-October/msg00049.html"&gt;Laine's email&lt;/a&gt; to virt-tools-list.&lt;/p&gt;</content><category term="fedora"></category><category term="virt"></category></entry><entry><title>python-bugzilla + bugzilla 5.0 API keys</title><link href="https://blog.wikichoon.com/2019/01/python-bugzilla-bugzilla-50-api-keys.html" rel="alternate"></link><published>2019-01-09T17:58:00-05:00</published><updated>2019-01-09T17:58:00-05:00</updated><author><name>Cole Robinson</name></author><id>tag:blog.wikichoon.com,2019-01-09:/2019/01/python-bugzilla-bugzilla-50-api-keys.html</id><summary type="html">&lt;p&gt;For many uses of &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; and python-bugzilla, it's necessary to actually be logged in to a bugzilla server. Creating bugs, editing bugs, querying private data, etc.&lt;/p&gt;
&lt;p&gt;Up until now anyone that's used the command line tool has periodically had to do a &lt;code&gt;bugzilla login&lt;/code&gt; to refresh their authentication …&lt;/p&gt;</summary><content type="html">&lt;p&gt;For many uses of &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; and python-bugzilla, it's necessary to actually be logged in to a bugzilla server. Creating bugs, editing bugs, querying private data, etc.&lt;/p&gt;
&lt;p&gt;Up until now anyone that's used the command line tool has periodically had to do a &lt;code&gt;bugzilla login&lt;/code&gt; to refresh their authentication cache. In older bugzilla versions this was an HTTP cookie, more recently it's a bugzilla API token. Generally &lt;code&gt;login&lt;/code&gt; calls were needed infrequently on a single machine as tokens would remain valid for a long time.&lt;/p&gt;
&lt;p&gt;Recently, bugzilla.redhat.com received a big update to bugzilla 5.0. However with that update it seems like API tokens now expire after a week, which has necessitated lots more &lt;code&gt;bugzilla login&lt;/code&gt; calls than I'm used to.&lt;/p&gt;
&lt;p&gt;Thankfully with &lt;strong&gt;bugzilla 5.0&lt;/strong&gt; and later there's a better option: API keys. Here's how to to use them transparently with &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; and all python-bugzilla library usage. Here's steps for enabling API keys with bugzilla.redhat.com, but the same process should roughly apply to other bugzilla instances too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Login to the bugzilla web UI&lt;/li&gt;
&lt;li&gt;Click on your email&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;Preferences&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;strong&gt;API Keys&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Generate an API key with an optional comment like &lt;code&gt;python-bugzilla&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Afterwards the screen will look something like this (updated in June 2020):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bugzilla web UI API key setup" height="384" src="https://blog.wikichoon.com/images/073-python-bugzilla-bugzilla-50-api-keys-2.png" width="640"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MY-FAKE-KEY&lt;/code&gt; is not my actual key, I replaced it for demo purposes. The actual key is a long string of characters and numbers.&lt;/p&gt;
&lt;p&gt;On &lt;code&gt;bugzilla.redhat.com&lt;/code&gt; the key is only visible in the red box when the key is initially created; refreshing the page will only show the numeric &lt;code&gt;API key ID&lt;/code&gt; which is not what you want. So if you missed copying that value the first time, revoke the key and create a new one.&lt;/p&gt;
&lt;p&gt;Once you've copied your key, write a bugzillarc file like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="na"&gt;$ cat ~/.config/python-bugzilla/bugzillarc&lt;/span&gt;
&lt;span class="k"&gt;[bugzilla.redhat.com]&lt;/span&gt;
&lt;span class="na"&gt;api_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;MY-FAKE-KEY&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it, &lt;code&gt;/usr/bin/bugzilla&lt;/code&gt; and python-bugzilla using tools should pick it up automagically. Note, API keys are as good as passwords in certain ways, so treat it with the same secrecy you would treat a password.&lt;/p&gt;</content><category term="fedora"></category></entry></feed>